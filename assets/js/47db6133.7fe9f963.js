"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[3299],{2821:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"modules/module-2-digital-twins-simulation/simulation-to-deployment","title":"Simulation to Deployment","description":"Workflow from simulation testing to physical deployment, including how insights from digital twins inform physical robot configuration.","source":"@site/docs/modules/module-2-digital-twins-simulation/simulation-to-deployment.md","sourceDirName":"modules/module-2-digital-twins-simulation","slug":"/modules/module-2-digital-twins-simulation/simulation-to-deployment","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-2-digital-twins-simulation/simulation-to-deployment","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/simulation"},{"inline":true,"label":"deployment","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/deployment"},{"inline":true,"label":"workflow","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/workflow"},{"inline":true,"label":"digital-twins","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/digital-twins"}],"version":"current","sidebarPosition":6,"frontMatter":{"id":"simulation-to-deployment","title":"Simulation to Deployment","sidebar_position":6,"description":"Workflow from simulation testing to physical deployment, including how insights from digital twins inform physical robot configuration.","tags":["simulation","deployment","workflow","digital-twins"],"learning_objectives":["lo-008"],"topic_category":"application"},"sidebar":"textbookSidebar","previous":{"title":"Humanoid Applications","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-2-digital-twins-simulation/humanoid-applications"},"next":{"title":"Glossary","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-2-digital-twins-simulation/glossary"}}');var t=n(4848),l=n(8453);const r={id:"simulation-to-deployment",title:"Simulation to Deployment",sidebar_position:6,description:"Workflow from simulation testing to physical deployment, including how insights from digital twins inform physical robot configuration.",tags:["simulation","deployment","workflow","digital-twins"],learning_objectives:["lo-008"],topic_category:"application"},a="Simulation to Deployment",o={},d=[{value:"The Simulation-to-Deployment Workflow",id:"the-simulation-to-deployment-workflow",level:2},{value:"Stage 1: Virtual Development",id:"stage-1-virtual-development",level:3},{value:"Stage 2: Validation",id:"stage-2-validation",level:3},{value:"Stage 3: Parameter Extraction",id:"stage-3-parameter-extraction",level:3},{value:"Stage 4: Physical Configuration",id:"stage-4-physical-configuration",level:3},{value:"Stage 5: Validation Testing",id:"stage-5-validation-testing",level:3},{value:"Stage 6: Iteration",id:"stage-6-iteration",level:3},{value:"Stage 7: Deployment",id:"stage-7-deployment",level:3},{value:"How Insights from Digital Twins Inform Physical Robot Configuration",id:"how-insights-from-digital-twins-inform-physical-robot-configuration",level:2},{value:"Optimized Parameters",id:"optimized-parameters",level:3},{value:"Validated Strategies",id:"validated-strategies",level:3},{value:"Performance Predictions",id:"performance-predictions",level:3},{value:"Safety Validation",id:"safety-validation",level:3},{value:"Example: Complete Workflow",id:"example-complete-workflow",level:2},{value:"Key Considerations",id:"key-considerations",level:2},{value:"Simulation-Physical Discrepancies",id:"simulation-physical-discrepancies",level:3},{value:"Safety First",id:"safety-first",level:3},{value:"Documentation",id:"documentation",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"simulation-to-deployment",children:"Simulation to Deployment"})}),"\n",(0,t.jsx)(i.p,{children:"The workflow from simulation testing to physical deployment is a critical process in humanoid robotics development. Digital twins enable comprehensive virtual testing, but successful deployment requires careful translation of virtual insights to physical reality."}),"\n",(0,t.jsx)(i.h2,{id:"the-simulation-to-deployment-workflow",children:"The Simulation-to-Deployment Workflow"}),"\n",(0,t.jsx)(i.p,{children:"The workflow from simulation to deployment follows these stages:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Virtual Development"})," - Design and test in digital twin"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validation"})," - Verify performance in simulation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Parameter Extraction"})," - Extract optimized parameters"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Physical Configuration"})," - Configure physical robot"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validation Testing"})," - Test on physical hardware"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Iteration"})," - Refine based on physical results"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Deployment"})," - Deploy validated solution"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stage-1-virtual-development",children:"Stage 1: Virtual Development"}),"\n",(0,t.jsx)(i.p,{children:"In the virtual development stage:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Design algorithms"})," in simulation environment"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Test configurations"})," using digital twin"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Optimize parameters"})," through automated testing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validate performance"})," against requirements"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Digital twins enable rapid iteration during this stage, allowing developers to explore many configurations quickly."}),"\n",(0,t.jsx)(i.h3,{id:"stage-2-validation",children:"Stage 2: Validation"}),"\n",(0,t.jsx)(i.p,{children:"Before moving to physical testing:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Verify performance"})," meets requirements"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Test edge cases"})," and failure scenarios"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Document results"})," for reference"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Identify potential issues"})," before physical testing"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stage-3-parameter-extraction",children:"Stage 3: Parameter Extraction"}),"\n",(0,t.jsx)(i.p,{children:"Extract optimized parameters from simulation:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Gait parameters"})," - Step length, timing, joint trajectories"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Manipulation strategies"})," - Grasp poses, trajectories, forces"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Control parameters"})," - Gains, thresholds, limits"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Safety parameters"})," - Emergency stop thresholds, collision responses"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stage-4-physical-configuration",children:"Stage 4: Physical Configuration"}),"\n",(0,t.jsx)(i.p,{children:"Configure physical robot with extracted parameters:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Upload parameters"})," to robot control system"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Calibrate sensors"})," to match simulation assumptions"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Verify hardware"})," matches simulation model"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Initialize safety systems"})," with validated thresholds"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stage-5-validation-testing",children:"Stage 5: Validation Testing"}),"\n",(0,t.jsx)(i.p,{children:"Test on physical hardware:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Start with safe scenarios"})," - Low-risk tests first"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Gradually increase complexity"})," - Build confidence"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Monitor performance"})," - Compare to simulation predictions"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Document differences"})," - Note discrepancies with simulation"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stage-6-iteration",children:"Stage 6: Iteration"}),"\n",(0,t.jsx)(i.p,{children:"Refine based on physical results:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Identify discrepancies"})," between simulation and reality"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Update simulation models"})," to better match physical behavior"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Adjust parameters"})," based on physical testing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Re-test in simulation"})," with updated models"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stage-7-deployment",children:"Stage 7: Deployment"}),"\n",(0,t.jsx)(i.p,{children:"Deploy validated solution:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Final validation"})," on physical robot"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Documentation"})," of final parameters"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Training"})," for operators"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Monitoring"})," during initial deployment"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"how-insights-from-digital-twins-inform-physical-robot-configuration",children:"How Insights from Digital Twins Inform Physical Robot Configuration"}),"\n",(0,t.jsx)(i.p,{children:"Digital twins provide insights that directly inform physical robot configuration:"}),"\n",(0,t.jsx)(i.h3,{id:"optimized-parameters",children:"Optimized Parameters"}),"\n",(0,t.jsx)(i.p,{children:"Digital twins identify optimal parameters through:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Parameter sweeps"})," - Testing many configurations"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Multi-objective optimization"})," - Balancing competing goals"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Performance evaluation"})," - Objective measurement of results"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Statistical analysis"})," - Finding robust solutions"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"These optimized parameters are directly applied to physical robots."}),"\n",(0,t.jsx)(i.h3,{id:"validated-strategies",children:"Validated Strategies"}),"\n",(0,t.jsx)(i.p,{children:"Digital twins validate strategies by:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Testing feasibility"})," - Ensuring strategies work in simulation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Evaluating performance"})," - Measuring effectiveness"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Identifying issues"})," - Finding problems before physical testing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Confirming safety"})," - Validating safe operation"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Validated strategies reduce risk when moving to physical testing."}),"\n",(0,t.jsx)(i.h3,{id:"performance-predictions",children:"Performance Predictions"}),"\n",(0,t.jsx)(i.p,{children:"Digital twins predict physical performance by:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Modeling robot dynamics"})," - Simulating physical behavior"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Predicting outcomes"})," - Estimating performance metrics"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Identifying limitations"})," - Finding constraints and boundaries"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Setting expectations"})," - Providing realistic performance targets"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Performance predictions help set realistic expectations for physical testing."}),"\n",(0,t.jsx)(i.h3,{id:"safety-validation",children:"Safety Validation"}),"\n",(0,t.jsx)(i.p,{children:"Digital twins validate safety by:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Testing failure scenarios"})," - Ensuring safety protocols work"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validating emergency stops"})," - Confirming rapid shutdown"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Testing collision responses"})," - Ensuring safe collision handling"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Modeling human interaction"})," - Validating human safety"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Safety validation ensures physical robots operate safely."}),"\n",(0,t.jsx)(i.h2,{id:"example-complete-workflow",children:"Example: Complete Workflow"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Example: Complete simulation-to-deployment workflow\nclass SimulationToDeployment:\n    """Manage workflow from simulation to physical deployment"""\n    \n    def __init__(self, digital_twin, physical_robot):\n        self.digital_twin = digital_twin\n        self.physical_robot = physical_robot\n        \n    def optimize_in_simulation(self, initial_parameters):\n        """Optimize parameters in digital twin"""\n        optimizer = GaitOptimizer(self.digital_twin)\n        optimized_params = optimizer.optimize_gait(initial_parameters)\n        \n        # Validate in simulation\n        validation_result = self.validate_in_simulation(optimized_params)\n        \n        if validation_result["success"]:\n            return optimized_params\n        else:\n            raise ValueError("Optimization failed validation")\n            \n    def validate_in_simulation(self, parameters):\n        """Validate parameters in simulation"""\n        # Test multiple scenarios\n        scenarios = [\n            "flat_ground",\n            "sloped_terrain",\n            "obstacle_avoidance",\n            "emergency_stop"\n        ]\n        \n        results = {}\n        for scenario in scenarios:\n            result = self.digital_twin.test_scenario(scenario, parameters)\n            results[scenario] = result["success"]\n            \n        return {\n            "success": all(results.values()),\n            "scenario_results": results\n        }\n        \n    def extract_parameters(self, optimized_params):\n        """Extract parameters for physical robot"""\n        return {\n            "gait_parameters": optimized_params["gait"],\n            "control_parameters": optimized_params["control"],\n            "safety_parameters": optimized_params["safety"]\n        }\n        \n    def configure_physical_robot(self, parameters):\n        """Configure physical robot with extracted parameters"""\n        # Upload gait parameters\n        self.physical_robot.set_gait_parameters(parameters["gait_parameters"])\n        \n        # Configure control system\n        self.physical_robot.set_control_parameters(parameters["control_parameters"])\n        \n        # Initialize safety systems\n        self.physical_robot.set_safety_parameters(parameters["safety_parameters"])\n        \n    def validate_on_physical_robot(self, parameters):\n        """Validate parameters on physical robot"""\n        # Start with safe test\n        result = self.physical_robot.test_safe_scenario()\n        \n        if not result["success"]:\n            return {"success": False, "reason": "safe_test_failed"}\n            \n        # Gradually increase complexity\n        complex_result = self.physical_robot.test_complex_scenario()\n        \n        return {\n            "success": complex_result["success"],\n            "performance": complex_result["performance"],\n            "differences": self.compare_to_simulation(complex_result)\n        }\n        \n    def compare_to_simulation(self, physical_result):\n        """Compare physical results to simulation predictions"""\n        simulation_result = self.digital_twin.get_predicted_performance()\n        \n        return {\n            "performance_difference": (\n                physical_result["performance"] - \n                simulation_result["predicted_performance"]\n            ),\n            "within_tolerance": abs(\n                physical_result["performance"] - \n                simulation_result["predicted_performance"]\n            ) < simulation_result["tolerance"]\n        }\n        \n    def iterate(self, physical_result):\n        """Iterate based on physical testing results"""\n        # Update simulation model if needed\n        if not physical_result["differences"]["within_tolerance"]:\n            self.digital_twin.update_model(physical_result)\n            \n        # Adjust parameters if needed\n        if physical_result["performance"] < 0.9:\n            adjusted_params = self.adjust_parameters(physical_result)\n            return adjusted_params\n            \n        return None\n        \n    def deploy(self, validated_parameters):\n        """Deploy validated solution"""\n        # Final configuration\n        self.configure_physical_robot(validated_parameters)\n        \n        # Final validation\n        final_result = self.validate_on_physical_robot(validated_parameters)\n        \n        if final_result["success"]:\n            # Document deployment\n            self.document_deployment(validated_parameters, final_result)\n            return {"success": True, "deployed": True}\n        else:\n            return {"success": False, "reason": "final_validation_failed"}\n'})}),"\n",(0,t.jsx)(i.p,{children:"This example demonstrates the complete workflow:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Optimization"})," in simulation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validation"})," before physical testing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Parameter extraction"})," for physical robot"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Physical configuration"})," and testing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Iteration"})," based on results"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Deployment"})," of validated solution"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"key-considerations",children:"Key Considerations"}),"\n",(0,t.jsx)(i.h3,{id:"simulation-physical-discrepancies",children:"Simulation-Physical Discrepancies"}),"\n",(0,t.jsx)(i.p,{children:"Differences between simulation and physical reality:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Model accuracy"})," - Simulation models may not perfectly match reality"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Sensor noise"})," - Physical sensors have noise not in simulation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Actuator limitations"})," - Physical actuators have constraints"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Environmental factors"})," - Real environments vary more than simulation"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"These discrepancies require:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Iterative refinement"})," - Updating simulation models"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Parameter adjustment"})," - Adapting to physical reality"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validation testing"})," - Confirming performance on hardware"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"safety-first",children:"Safety First"}),"\n",(0,t.jsx)(i.p,{children:"Always prioritize safety:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Start with safe scenarios"})," - Low-risk tests first"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Gradual progression"})," - Increase complexity slowly"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Monitor closely"})," - Watch for unexpected behavior"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Have safety protocols"})," - Emergency stops ready"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"documentation",children:"Documentation"}),"\n",(0,t.jsx)(i.p,{children:"Document the process:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Parameters"})," - Record optimized values"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Results"})," - Document test outcomes"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Differences"})," - Note simulation-physical discrepancies"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Lessons learned"})," - Capture insights for future work"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(i.p,{children:"The simulation-to-deployment workflow moves from virtual development through validation, parameter extraction, physical configuration, testing, iteration, and final deployment. Digital twins provide optimized parameters, validated strategies, performance predictions, and safety validation that inform physical robot configuration. Successful deployment requires careful translation of virtual insights to physical reality, accounting for simulation-physical discrepancies and prioritizing safety throughout the process."}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.p,{children:["You've now learned about digital twins, simulation fundamentals, sensor integration, and practical applications. Review the ",(0,t.jsx)(i.a,{href:"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-2-digital-twins-simulation/glossary",children:"Glossary"})," for key terminology, or return to ",(0,t.jsx)(i.a,{href:"./module-2-digital-twins-simulation",children:"Module Overview"})," to explore other sections."]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>a});var s=n(6540);const t={},l=s.createContext(t);function r(e){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:i},e.children)}}}]);