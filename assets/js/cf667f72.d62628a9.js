"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[96],{6265:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"modules/module-1-ros2-nervous-system/communication-patterns","title":"Communication Patterns","description":"Understanding ROS 2 communication patterns: publish-subscribe (topics), request-response (services), and action-based patterns.","source":"@site/docs/modules/module-1-ros2-nervous-system/communication-patterns.md","sourceDirName":"modules/module-1-ros2-nervous-system","slug":"/modules/module-1-ros2-nervous-system/communication-patterns","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-1-ros2-nervous-system/communication-patterns","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"ros2","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/ros-2"},{"inline":true,"label":"communication-patterns","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/communication-patterns"},{"inline":true,"label":"topics","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/topics"},{"inline":true,"label":"services","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/services"},{"inline":true,"label":"actions","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/actions"},{"inline":true,"label":"publish-subscribe","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/tags/publish-subscribe"}],"version":"current","sidebarPosition":3,"frontMatter":{"id":"communication-patterns","title":"Communication Patterns","sidebar_position":3,"description":"Understanding ROS 2 communication patterns: publish-subscribe (topics), request-response (services), and action-based patterns.","tags":["ros2","communication-patterns","topics","services","actions","publish-subscribe"],"learning_objectives":["lo-002"]},"sidebar":"textbookSidebar","previous":{"title":"ROS 2 Fundamentals","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-1-ros2-nervous-system/ros2-fundamentals"},"next":{"title":"Humanoid Robotics Applications","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-1-ros2-nervous-system/humanoid-applications"}}');var t=s(4848),r=s(8453);const o={id:"communication-patterns",title:"Communication Patterns",sidebar_position:3,description:"Understanding ROS 2 communication patterns: publish-subscribe (topics), request-response (services), and action-based patterns.",tags:["ros2","communication-patterns","topics","services","actions","publish-subscribe"],learning_objectives:["lo-002"]},a="Communication Patterns",c={},l=[{value:"Overview of Communication Patterns",id:"overview-of-communication-patterns",level:2},{value:"Publish-Subscribe Pattern (Topics)",id:"publish-subscribe-pattern-topics",level:2},{value:"When to Use Topics",id:"when-to-use-topics",level:3},{value:"Example: Publish-Subscribe Pattern",id:"example-publish-subscribe-pattern",level:3},{value:"Advantages of Publish-Subscribe",id:"advantages-of-publish-subscribe",level:3},{value:"Request-Response Pattern (Services)",id:"request-response-pattern-services",level:2},{value:"When to Use Services",id:"when-to-use-services",level:3},{value:"Example: Request-Response Pattern",id:"example-request-response-pattern",level:3},{value:"Advantages of Request-Response",id:"advantages-of-request-response",level:3},{value:"Action-Based Pattern",id:"action-based-pattern",level:2},{value:"When to Use Actions",id:"when-to-use-actions",level:3},{value:"Example: Action-Based Pattern",id:"example-action-based-pattern",level:3},{value:"Advantages of Action-Based",id:"advantages-of-action-based",level:3},{value:"Choosing the Right Pattern",id:"choosing-the-right-pattern",level:2},{value:"Key Decision Factors",id:"key-decision-factors",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"communication-patterns",children:"Communication Patterns"})}),"\n",(0,t.jsx)(n.p,{children:"Now that you understand the core ROS 2 concepts, let's explore how these components communicate. ROS 2 provides three distinct communication patterns, each optimized for different types of interactions in robotic systems."}),"\n",(0,t.jsx)(n.h2,{id:"overview-of-communication-patterns",children:"Overview of Communication Patterns"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 offers three primary communication patterns:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publish-Subscribe (Topics)"})," - Asynchronous, one-to-many communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request-Response (Services)"})," - Synchronous, one-to-one communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action-Based"})," - Asynchronous, long-running tasks with feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Understanding when to use each pattern is crucial for designing effective robotic systems."}),"\n",(0,t.jsx)(n.h2,{id:"publish-subscribe-pattern-topics",children:"Publish-Subscribe Pattern (Topics)"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"publish-subscribe pattern"})," is the most common communication mechanism in ROS 2. It enables ",(0,t.jsx)(n.strong,{children:"asynchronous, decoupled communication"})," where:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publishers"})," send messages to a topic without knowing who receives them"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subscribers"})," receive messages from a topic without knowing who sends them"]}),"\n",(0,t.jsx)(n.li,{children:"Multiple publishers and subscribers can use the same topic"}),"\n",(0,t.jsxs)(n.li,{children:["Communication is ",(0,t.jsx)(n.strong,{children:"one-way"})," (publisher \u2192 subscriber)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-topics",children:"When to Use Topics"}),"\n",(0,t.jsx)(n.p,{children:"Topics are ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Continuous data streams"})," - Sensor data (camera images, IMU readings, joint positions)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State information"})," - Robot pose, battery level, system status"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Commands"})," - Movement commands, mode changes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Broadcasting"})," - Information that multiple nodes need simultaneously"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-publish-subscribe-pattern",children:"Example: Publish-Subscribe Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Publisher: Sending sensor data\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\n\nclass CameraPublisher(Node):\n    def __init__(self):\n        super().__init__('camera_publisher')\n        self.publisher = self.create_publisher(Image, 'camera/image', 10)\n        self.timer = self.create_timer(0.033, self.publish_image)  # ~30 FPS\n    \n    def publish_image(self):\n        # In a real implementation, this would capture an actual image\n        msg = Image()\n        # ... populate image data ...\n        self.publisher.publish(msg)\n        self.get_logger().info('Published camera image')\n\n# Subscriber: Receiving sensor data\nclass ImageProcessor(Node):\n    def __init__(self):\n        super().__init__('image_processor')\n        self.subscription = self.create_subscription(\n            Image,\n            'camera/image',\n            self.image_callback,\n            10\n        )\n    \n    def image_callback(self, msg):\n        # Process the received image\n        self.get_logger().info('Received and processing image')\n        # ... image processing logic ...\n"})}),"\n",(0,t.jsx)(n.p,{children:"This example shows how a camera node publishes images to a topic, and an image processing node subscribes to receive and process those images. Multiple processing nodes could subscribe to the same topic if needed."}),"\n",(0,t.jsx)(n.h3,{id:"advantages-of-publish-subscribe",children:"Advantages of Publish-Subscribe"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decoupled"})," - Publishers and subscribers don't need to know about each other"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalable"})," - Easy to add more subscribers without modifying publishers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous"})," - No blocking, nodes continue their work independently"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"One-to-many"})," - One publisher can serve multiple subscribers"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"request-response-pattern-services",children:"Request-Response Pattern (Services)"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"request-response pattern"})," (services) provides ",(0,t.jsx)(n.strong,{children:"synchronous communication"})," where:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"client"})," node sends a request to a ",(0,t.jsx)(n.strong,{children:"server"})," node"]}),"\n",(0,t.jsxs)(n.li,{children:["The client ",(0,t.jsx)(n.strong,{children:"waits"})," for a response"]}),"\n",(0,t.jsxs)(n.li,{children:["Communication is ",(0,t.jsx)(n.strong,{children:"two-way"})," (request \u2192 response)"]}),"\n",(0,t.jsxs)(n.li,{children:["The interaction is ",(0,t.jsx)(n.strong,{children:"blocking"})," - the client waits until the server responds"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-services",children:"When to Use Services"}),"\n",(0,t.jsx)(n.p,{children:"Services are ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"On-demand actions"}),' - "Turn on the camera," "Get current battery level"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Configuration changes"}),' - "Set motor speed to 50%," "Change control mode"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Query operations"}),' - "What is the robot\'s current position?"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous operations"})," - When you need an immediate response"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-request-response-pattern",children:"Example: Request-Response Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Service Server: Providing robot status\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import Trigger\n\nclass RobotStatusService(Node):\n    def __init__(self):\n        super().__init__('robot_status_service')\n        self.srv = self.create_service(\n            Trigger,\n            'get_robot_status',\n            self.status_callback\n        )\n        self.is_operational = True\n    \n    def status_callback(self, request, response):\n        response.success = self.is_operational\n        response.message = \"Robot is operational\" if self.is_operational else \"Robot is offline\"\n        return response\n\n# Service Client: Requesting robot status\nclass StatusChecker(Node):\n    def __init__(self):\n        super().__init__('status_checker')\n        self.client = self.create_client(Trigger, 'get_robot_status')\n    \n    def check_status(self):\n        request = Trigger.Request()\n        future = self.client.call_async(request)\n        # Wait for response\n        rclpy.spin_until_future_complete(self, future)\n        if future.result() is not None:\n            response = future.result()\n            self.get_logger().info(f'Status: {response.message}')\n        else:\n            self.get_logger().error('Service call failed')\n"})}),"\n",(0,t.jsx)(n.p,{children:"This example shows how a status checker node can request the robot's status from a service server and receive an immediate response."}),"\n",(0,t.jsx)(n.h3,{id:"advantages-of-request-response",children:"Advantages of Request-Response"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous"})," - Guaranteed response before continuing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reliable"})," - Client knows if the request succeeded or failed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simple"})," - Straightforward request-response model"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"On-demand"})," - Only executed when explicitly requested"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"action-based-pattern",children:"Action-Based Pattern"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"action-based pattern"})," combines aspects of both topics and services:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Like services, actions have a ",(0,t.jsx)(n.strong,{children:"goal"})," (request to start a task)"]}),"\n",(0,t.jsxs)(n.li,{children:["Like topics, actions provide ",(0,t.jsx)(n.strong,{children:"continuous feedback"})," during execution"]}),"\n",(0,t.jsxs)(n.li,{children:["Actions provide a ",(0,t.jsx)(n.strong,{children:"final result"})," when the task completes"]}),"\n",(0,t.jsxs)(n.li,{children:["Communication is ",(0,t.jsx)(n.strong,{children:"asynchronous"})," - the client doesn't block waiting for completion"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-actions",children:"When to Use Actions"}),"\n",(0,t.jsx)(n.p,{children:"Actions are ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Long-running tasks"})," - Navigation, manipulation, complex behaviors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tasks requiring feedback"})," - Progress updates during execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancellable operations"})," - Tasks that might need to be stopped"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complex behaviors"})," - Multi-step processes that take time"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-action-based-pattern",children:"Example: Action-Based Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Action Server: Executing a navigation task\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer\nfrom nav2_msgs.action import NavigateToPose\n\nclass NavigationActionServer(Node):\n    def __init__(self):\n        super().__init__('navigation_server')\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,\n            'navigate_to_pose',\n            self.execute_callback\n        )\n    \n    def execute_callback(self, goal_handle):\n        goal = goal_handle.request\n        feedback_msg = NavigateToPose.Feedback()\n        result = NavigateToPose.Result()\n        \n        # Execute navigation with periodic feedback\n        total_distance = self.calculate_distance(goal.pose)\n        current_distance = 0\n        \n        while current_distance < total_distance:\n            # Update progress\n            current_distance += 0.1  # Simulate movement\n            feedback_msg.distance_remaining = total_distance - current_distance\n            goal_handle.publish_feedback(feedback_msg)\n            \n            # Check if goal was cancelled\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                return result\n            \n            self.get_logger().info(f'Progress: {current_distance:.1f}/{total_distance:.1f}m')\n        \n        # Task complete\n        goal_handle.succeed()\n        result.pose = goal.pose\n        return result\n    \n    def calculate_distance(self, pose):\n        # Simplified distance calculation\n        return 5.0  # meters\n"})}),"\n",(0,t.jsx)(n.p,{children:"This example shows how a navigation action server executes a long-running task while providing continuous feedback on progress."}),"\n",(0,t.jsx)(n.h3,{id:"advantages-of-action-based",children:"Advantages of Action-Based"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"})," - Continuous updates during long-running tasks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancellable"})," - Tasks can be stopped if needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous"})," - Client doesn't block during execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexible"})," - Combines request-response with continuous updates"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"choosing-the-right-pattern",children:"Choosing the Right Pattern"}),"\n",(0,t.jsx)(n.p,{children:"Here's a decision guide for selecting the appropriate communication pattern:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{children:"Recommended Pattern"}),(0,t.jsx)(n.th,{children:"Reason"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Continuous sensor data"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Topic"})}),(0,t.jsx)(n.td,{children:"Asynchronous, multiple subscribers"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"On-demand status check"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Service"})}),(0,t.jsx)(n.td,{children:"Synchronous, immediate response needed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Navigation to location"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Action"})}),(0,t.jsx)(n.td,{children:"Long-running, needs progress feedback"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Broadcasting commands"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Topic"})}),(0,t.jsx)(n.td,{children:"One-to-many, asynchronous"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Configuration change"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Service"})}),(0,t.jsx)(n.td,{children:"Synchronous, need confirmation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Complex manipulation"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Action"})}),(0,t.jsx)(n.td,{children:"Long-running, needs feedback and cancellation"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"key-decision-factors",children:"Key Decision Factors"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Do you need a response?"})," \u2192 Use Service or Action"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Is the task long-running?"})," \u2192 Use Action"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Do you need feedback during execution?"})," \u2192 Use Action"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Is it continuous data?"})," \u2192 Use Topic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Do multiple nodes need the information?"})," \u2192 Use Topic"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics (Publish-Subscribe)"}),": Best for continuous, asynchronous data streams"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services (Request-Response)"}),": Best for on-demand, synchronous interactions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Best for long-running tasks that need feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Understanding these patterns and when to use each one is essential for designing effective ROS 2 systems, especially in complex applications like humanoid robotics."}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.p,{children:["Now that you understand ROS 2 communication patterns, proceed to ",(0,t.jsx)(n.a,{href:"/Physical-AI-Humanoid-Robotics-Textbook/modules/module-1-ros2-nervous-system/humanoid-applications",children:"Humanoid Robotics Applications"})," to see how these patterns are applied in real humanoid robot scenarios."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);